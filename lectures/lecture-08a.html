<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>ETC3250/5250: Introduction to Machine Learning</title>
    <meta charset="utf-8" />
    <meta name="author" content="Professor Di Cook" />
    <script src="lib/header-attrs-2.7/header-attrs.js"></script>
    <link href="lib/remark-css-0.0.1/ninjutsu.css" rel="stylesheet" />
    
    <!--
    <script defer src="assets/all.min.js"></script>

    Need below to enable css contents

    <script>
      window.FontAwesomeConfig = {
        searchPseudoElements: true
      }
    </script>

    -->
    <link rel="stylesheet" href="assets/font-awesome-all.css" type="text/css" />
    <link rel="stylesheet" href="assets/tachyons-addon.css" type="text/css" />
    <link rel="stylesheet" href="assets/animate.css" type="text/css" />
    <link rel="stylesheet" href="assets/fira-code.css" type="text/css" />
    <link rel="stylesheet" href="assets/boxes.css" type="text/css" />
    <link rel="stylesheet" href="assets/table.css" type="text/css" />
    <link rel="stylesheet" href="assets/styles.css" type="text/css" />
    <link rel="stylesheet" href="assets/monash-brand.css" type="text/css" />
    <link rel="stylesheet" href="assets/monash-fonts.css" type="text/css" />
    <link rel="stylesheet" href="assets/slide-types.css" type="text/css" />
    <link rel="stylesheet" href="assets/custom.css" type="text/css" />
    <link rel="stylesheet" href="assets/panelset.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">






class: middle center hide-slide-number monash-bg-gray80





.info-box.w-50.bg-white[
These slides are viewed best by Chrome or Firefox and occasionally need to be refreshed if elements did not load properly. See &lt;a href=lecture-08a.pdf&gt;here for the PDF &lt;i class="fas fa-file-pdf"&gt;&lt;/i&gt;&lt;/a&gt;. 
]

&lt;br&gt;

.white[Press the **right arrow** to progress to the next slide!]



---

class: title-slide
count: false
background-image: url("images/bg-02.png")

# .monash-blue[ETC3250/5250: Introduction to Machine Learning]

&lt;h1 class="monash-blue" style="font-size: 30pt!important;"&gt;&lt;/h1&gt;

&lt;br&gt;

&lt;h2 style="font-weight:900!important;"&gt;Neural netorks and deep learning&lt;/h2&gt;

.bottom_abs.width100[

Lecturer: *Professor Di Cook*

Department of Econometrics and Business Statistics

&lt;i class="fas fa-envelope"&gt;&lt;/i&gt;  ETC3250.Clayton-x@monash.edu

&lt;i class="fas fa-calendar-alt"&gt;&lt;/i&gt; Week 8a

&lt;br&gt;

]





---
class: split-two

.column[.pad50px[

# What number is this?

&lt;br&gt;

This is a three, right?

]]

.column[.content.vmiddle.center[


&lt;img src="images/lecture-08a/three-1.JPG" style="width: 80%"/&gt;


]]


---
class: split-two

.column[.pad50px[

# What number is this?

&lt;br&gt;

Is this also a three?

]]

.column[.content.vmiddle.center[


&lt;img src="images/lecture-08a/three-2.JPG" style="width: 80%"/&gt;


]]

---

class: split-two

.column[.pad50px[

# What number is this?

&lt;br&gt;

But what about this number? Not a three?

]]

.column[.content.vmiddle.center[


&lt;img src="images/lecture-08a/five.JPG" style="width: 80%"/&gt;


]]
---
# The human brain

The human brain can efficiently recognise that although the images of the two threes are different, they are the same number, and are both distinct from the five.

&lt;center&gt;
&lt;img src="images/lecture-08a/dif.png" style="width: 80%"/&gt;
&lt;/center&gt;
---

class: split-two

.column[.pad50px[

# MNIST data
&lt;br&gt;
The .monash-blue2[MNIST data] was presented to AT&amp;T Bell Lab's to build automatic mail sorting machines.

.monash-orange2[Goal:] Analyse handwritten digits and predict numbers written, given a `\(28 \times 28\)` grid of pixels for each of the  60000 training images. Digits range from 0-9. 

]]


.column[.content.vmiddle.center[


&lt;img src="images/lecture-08a/MNIST.png" style="width: 80%"/&gt;

.font_smaller2[Sample images from MNIST test dataset .]
]]

---
class: split-two

.column[.pad50px[

# MNIST data

.monash-blue2[How do we do this?]

Humans are good at detecting different features about the images, such as thickness of line, angles, edges, completeness of circles, etc.

It is evident a complex relationship is presented in the images. .monash-orange2[Neural networks] can help us automatically capture these complexities.

]]

.column[.content.vmiddle.center[


&lt;img src="images/lecture-08a/titterington.png" style="width: 80%"/&gt;

.font_smaller2[Image from [Neural Networks: A Review from a Statistical Perspective](https://projecteuclid.org/euclid.ss/1177010638)]
]]
---

class: split-two

.column[.pad50px[

# So, what are neural networks?

**Idea:** .monash-blue2[Capture a complex relationship between outputs and inputs by creating layers of derived variables.]

`\(y\)` = output variable

`\(x\)` = original input variable

`\(f(x)\)` = derived variable input

]]

.column[.content.vmiddle.center[

$$ y = f_1(f_2(\dots (f_d(x))))$$

&lt;br&gt;

&lt;img src="images/lecture-08a/feedforward.png" style="width: 80%"/&gt;

.font_smaller2[Source: [Hands on Machine Learning with R - Deep Learning](https://bradleyboehmke.github.io/HOML/deep-learning.html)]
]]



---

# How do we build a neural network?

&lt;br&gt;

To build a feedforward neural network, we need .monash-orange2[four key components:]

1. Input data (*in this case, the MNIST data*)
2. A pre-defined network architecture;
3. A feedback mechanism (optimisation) to enable the network to learn; and 
4. A model training approach.

&lt;br&gt;&lt;br&gt;
Following instructions at [Hands on Machine Learning in R](https://bradleyboehmke.github.io/HOML/deep-learning.html) Chapter 13. 
---

class: transition middle center

# 1. Preparing the data



---

# Data preparation

&lt;br&gt;

There are some data cleaning steps we need to keep in mind before we use neural networks.

- Data needs input to be *numeric*. This means if our data has categorical variables, we will need to represent these as *dummy variables* (revise, Week 2!). This is also called .monash-orange2[one-hot encoding] in ML literature.
- Neural nets are sensitive to scale of the feature values - hence they should be *standardised* first (have mean zero and unit variance).
- If response is categorical (such as "0" through "9" response in MNIST data) - needs to be recoded as binary matrix. 
---

# Data preparation

This arose when AT&amp;T Bell Labâ€™s was asked to help build automatic mail-sorting machines for the USPS aroound 1990. 
Data available at http://yann.lecun.com/exdb/mnist/ but owner has blocked automatic download with `dslabs::read_mnist()`. 

To get mnist data follow the instructions at https://tensorflow.rstudio.com/guide/tfestimators/examples/mnist/




---

```r
library(tidyverse) 
library(keras)

load(here::here("data/MNIST_data/mnist.rda"))
mnist$train$x &lt;- mnist$train$x / 255
mnist$test$x &lt;- mnist$test$x / 255
mnist_x &lt;- mnist$train$x
mnist_y &lt;- mnist$train$y

# Rename columns and standardize feature values
colnames(mnist_x) &lt;- paste0("V", 1:ncol(mnist_x))
p &lt;- ncol(mnist_x)

# One-hot encode response
# mnist_y &lt;- to_categorical(mnist_y, 10) FAILURE
mnist_y_mat &lt;- matrix(0, length(mnist_y), 10)
for (i in 1:nrow(mnist_y_mat))
  mnist_y_mat[i,mnist_y[i]] &lt;- 1
mnist_y &lt;- mnist_y_mat
```

---

class: transition middle center

# 2. Network Architecture

---
# Network architecture

&lt;br&gt;

When building architecture for the neural network, we are concerned about two key features: 

- The number of layers and nodes, and
- How signal is activated throughout the network.

---

class: split-two

.column[.pad50px[

# Layers and nodes

Our complex relationships are captured using layers and nodes. There are two different types of layers, namely,

- Input and output layers, and
- Hidden layers.
    - No well-defined approach for selecting the number of hidden layers - this is just one of many hyperparameters we will need to tune! .monash-orange2[2-5 layers works well most of the time for regular tabular data].
    - The more hidden layers - the longer the model will take to train (as we are adding more parameters!)



.font_smaller2[Source: [Gabriela de Quiroz](https://github.com/gdequeiroz/2018-04-25_intro-to-deep-learning-with-R/blob/master/presentation/basic-concepts.pdf)]

]]

.column[.content.vmiddle.center[


&lt;img src="images/lecture-08a/nn_layers.JPG" style="width: 80%"/&gt;


]]


---

# Output layers


Choice of nodes for the output layer is determined by the ML task.

- If you are doing regression - a single node.
- Classification - a node for each class if multiclass.
- If binary, single node for probability of predicting success.

&lt;br&gt;

.tip[**Think!** How many output nodes will MNIST data neural network contain?  ðŸ¤”]
---

# Building network structure in R

We use the `keras` package to build neural networks in R. This is *very different* to other forms of ML algorithms in R. In `keras`, we first define the network structure as a standalone from our data.


```r
library(keras)
model &lt;- keras_model_sequential() %&gt;%
  layer_dense(units = 16,
              input_shape = p) %&gt;%
  layer_dense(units = 16) %&gt;%
* layer_dense(units = 10)
```


---

# Activation - how do the layers speak?

&lt;br&gt;


Now that we have our structure in place, we need to determine how to pass signal throughout the network. 

&lt;br&gt;
&lt;br&gt;

It uses methods we already know: .monash-orange2[logistic] and .monash-orange2[linear regression.]

---
# But first, some history


"A logical calculus of the ideas immanent in nervous activity" (1943)
Warren S. McCulloch &amp; Walter Pitts

Mathematical model for a neuron.

&lt;center&gt;
&lt;img src="images/lecture-08a/neuron.gif" /&gt;
&lt;/center&gt;

---
# Logistic regression

Remember the logistic function:

`\begin{align}
y &amp;=&amp; \frac{e^{\beta_0+\sum_{j=1}^p\beta_jx_j}}{1+e^{\beta_0+\sum_{j=1}^p\beta_jx_j}}\\
  &amp;=&amp; \frac{1}{1+e^{-(\beta_0+\sum_{j=1}^p\beta_jx_j)}}
\end{align}`

Alternatively,

`$$\log_e\frac{y}{1 - y} = \beta_0+\sum_{j=1}^p\beta_jx_j$$`


---
class: split-50
layout: false

.column[.pad50px[

# Logistic regression

&lt;br&gt;

What the .monash-orange2[logistic function] looks like:

`\begin{align}
y =\frac{1}{1+e^{-(\beta_0+\sum_{j=1}^p\beta_jx_j)}}
\end{align}`

]]

.column[.content.vmiddle.center[


&lt;img src="images/lecture-08a/unnamed-chunk-6-1.png" width="80%" style="display: block; margin: auto;" /&gt;


]]
---
class: middle

&lt;img src="images/lecture-08a/unnamed-chunk-7-1.png" width="80%" style="display: block; margin: auto;" /&gt;

&lt;center&gt;
.font_large[Hang on to this idea....]
&lt;/center&gt;
---

class: split-50

.column[.pad50px[

# Linear regression as a network


`$$\hat{y} =\beta_0+\sum_{j=1}^p\beta_jx_j$$`

Drawing as a network model: 

`\(p\)` .monash-orange2[inputs] (predictors), multiplied by .monash-orange2[weights] (coefficients), summed, add a .monash-orange2[constant], predicts .monash-orange2[output] (response)

]]
.column[.content.vmiddle[



&lt;img src="images/lecture-08a/reg_nn.png" style="width: 90%; align: center" /&gt;

]]



---
# Network explanation - hidden layers

`$$\hat{y} =\alpha_{0}+\sum_{k=1}^s(\alpha_{k}(\beta_{j0}+\sum_{j=1}^p\beta_{jk}x_j))$$`

A linear regression model nested within a linear regression model allows for intrinsic dimension reduction, or expansion.

&lt;center&gt;
&lt;img src="images/lecture-08a/nn.png" style="width: 60%; align: center" /&gt;
&lt;/center&gt;

---
# Two layer perceptron

This is a single output, 2 layer, perceptron (neural network), with a linear threshold.

`\begin{align}
\hat{y} =\alpha_{0}+\sum_{k=1}^s(\alpha_{k}(\beta_{j0}+\sum_{j=1}^p\beta_{jk}x_j))
\end{align}`


&lt;center&gt;
&lt;img src="images/lecture-08a/nn_annotate.png" style="width: 70%; align: center" /&gt;
&lt;/center&gt;







---

Back to logistic regression: When the proportion gets to threshold, it .monash-orange2[activates] an event to happen `\((Y=1)\)`.

&lt;img src="images/lecture-08a/unnamed-chunk-8-1.png" width="50%" style="display: block; margin: auto;" /&gt;

---
# Activation functions

`\begin{align}
\hat{y} =\color{orange}g\color{orange}(\alpha_{0}+\sum_{k=1}^s(\alpha_{k}\color{orange}f\color{orange}(\beta_{0k}+\sum_{j=1}^p\beta_{jk}x_j)\color{orange})\color{orange})
\end{align}`

Let `\(u=\beta_0+\sum_{j=1}^p\beta_jx_j\)`
- `\(\texttt{Logistic:} \quad \color{orange}{\frac{1}{1+e^{-u}}}\)`
- `\(\texttt{Gaussian radial:} \quad \color{orange}{\frac{1}{\sqrt{2\pi}}e^{-u^2/2}}\)`
- `\(\texttt{Hyperbolic tangent:} \quad \color{orange}{\frac{e^u-e^{-u}}{e^u+e^{-u}}}\)`

---
# Example

Consider the wiggly data

&lt;img src="images/lecture-08a/unnamed-chunk-9-1.png" width="50%" style="display: block; margin: auto;" /&gt;

---

# Overall fit 

This is the best fit from many, many random starts, with different parameters. It's a beautiful fit. 

&lt;img src="images/lecture-08a/unnamed-chunk-10-1.png" width="50%" style="display: block; margin: auto;" /&gt;

---
# Individual layers

The best fit used four nodes in the hidden layer, each fitting a logistic regression. Node 2 does the most work, catching the main linear divide, and node 1 catches the first wiggle, node 4 the second wiggle and node 3 the third wiggle. 

&lt;img src="images/lecture-08a/unnamed-chunk-11-1.png" width="90%" style="display: block; margin: auto;" /&gt;


---

# Adding in activation

Activations determine whether the node has enough information to send a signal to the next layer. For example, the `relu` activation function is takes summed weighted inputs and transforming them to 0 (not fire) or &gt;
0 (fire). 

To add in activation information to our model in `keras`, we simply adjust our model structure previously by adding in the activation functions we would like to use for each layer.


```r
model &lt;- keras_model_sequential() %&gt;%
  layer_dense(units = 16, 
*             activation = "relu",
              input_shape = p) %&gt;%
  layer_dense(units = 16, activation = "relu") %&gt;%
  layer_dense(units = 10, activation = "softmax")
```

---
class: transition middle center

# 3. Feedback Mechanism




---

# Compiling the model

Now that we have a model architecture in place - how will the model *learn* from the data? To do this, we need to specify a .monash-orange2[**loss function**] and .monash-orange2[**optimiser**] to use during training.

- The *loss function* (also called objective function) helps measure performance. For example, in regression use the MSE, and for classification you may use cross entropy.
- The *optimiser* controls which optimisation algorithm is implemented in our NN. 



```r
model %&gt;%   compile(
*   loss = 'categorical_crossentropy',
    optimizer = "rmsprop",
    metrics = c('accuracy')
  )
```

---

class: transition middle center

# 4. Model Training

---

# Model training

Now that we have created the model specification, we are ready to give it some data! We can use the `fit` function in `keras` to achieve this.


```r
fit &lt;- model %&gt;% fit(
  x = mnist_x,
  y = mnist_y,
  batch_size = 512,
  epochs = 10,
  validation_split = 0.2
)
```

- `batch_size` refers to the number of samples used to estimate the error gradient for the optimisation at any time, manages computational load, and model stability. 
- `epoch` refers to how many iterations through the entire training data, it is typically large.
- `validation_split` sets a hold-out proportion to avoid over-fitting.

---

class: split-50

.column[.pad50px[

# Model training

We can plot the accuracy and loss of the neural network using the `plot` function.


```r
plot(fit)
```



]]
.column[.content.vmiddle[

&lt;img src="https://bradleyboehmke.github.io/HOML/11-deep-learning_files/figure-html/model-train-1.png" width="95%"&gt;

]]



---

class: transition middle center

# So why don't we use neural networks for all machine learning problems?


---

class: split-two

.column[.pad50px[

# Minimal interpretability

&lt;br&gt;

- Core concept of .monash-orange2[prediction] vs .monash-orange2[inference].
- Neural networks are seen as a black box type of model, with limited information provided to as how the neural net is making decisions. (*Contrast this to trees, or logistic regression, say*)

]]

.column[.content.vmiddle.center[


&lt;img src="images/lecture-08a/hidden-layers.jpg" style="width: 80%"/&gt;

.font_smaller2[Source: Machine Learning Memes for Convolutional Teens]


]]


---
class: split-two

.column[.pad50px[

# Data intensive

&lt;br&gt;

- Deep learning algorithms don't work well when the number of features is larger than the number of observations (highly over-parameterised).
- If we only have a limited number of training data points, the model can potentially .monash-orange2[overfit] and fit very closely to the training data whilst lacking predictive performance for new data.

]]

.column[.content.vmiddle.center[


&lt;img src="images/lecture-08a/nodata.png" style="width: 80%"/&gt;

.font_smaller2[Source: Machine Learning Memes for Convolutional Teens]
]]
---
class: split-two

.column[.pad50px[

# Computationally intensive

&lt;br&gt;

- Many calculations are required to estimate all of the parameters in many neural networks (the one we have shown today is quite basic ).
- Deep learning involves huge amounts of matrix multiplications and other operations.
- Often used in conjuction with GPUs to paralellise computations.

]]

.column[.content.vmiddle.center[


&lt;img src="images/lecture-08a/intense.png" style="width: 80%"/&gt;

.font_smaller2[Source: Machine Learning Memes for Convolutional Teens]

]]
---




background-size: cover
class: title-slide
background-image: url("images/bg-02.png")

&lt;a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"&gt;&lt;img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /&gt;&lt;/a&gt;&lt;br /&gt;This work is licensed under a &lt;a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt;.


.bottom_abs.width100[

Lecturer: *Professor Di Cook*

Department of Econometrics and Business Statistics

&lt;i class="fas fa-envelope"&gt;&lt;/i&gt;  ETC3250.Clayton-x@monash.edu

&lt;i class="fas fa-calendar-alt"&gt;&lt;/i&gt; Week 8a

&lt;br&gt;

]




    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="lib/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "magula",
"highlightLanguage": "r",
"highlightLines": true,
"highlightSpans": false,
"countIncrementalSlides": false,
"slideNumberFormat": "%current%/%total%",
"navigation": {
"scroll": false,
"touch": true,
"click": false
},
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'lib/mathjax-local/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
